Imperative Programming Vacation Work 
Andrei-Costin Constantinescu


..........................................................................................
-- Sheet 1 --


Question 1

(a)
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int): Int = {
    var i = 0; var j = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            a[0 .. i) together with b[0 .. j) are the smallest    
    //                      i + j elements in a and b considered together and 
    //            there is no element common to a[0 .. i) and b[0 .. j).
	while (i < N && j < M && a(i) != b(j)) {
	    if (a(i) < b(j))
	    	i = i + 1
	    else
		    j = j + 1
	}
	a(i) // We know that an answer surely exists, so this is well behaved
}

The program may never access elements of the arrays outside safe bounds
because the only time when array accesses happen is inside the loop body, and
the loop guards together with the invariant read 0 <= i < N, 0 <= j < M.


(b) 
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int): Option[Int] = {
    var i = 0; var j = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            a[0 .. i) together with b[0 .. j) are the smallest
    //                      i + j elements in a and b considered together and 
    //            there is no element common to a[0 .. i) and b[0 .. j).
    while (i < N && j < M && a(i) != b(j)) {
       if (a(i) < b(j)) 
            i = i + 1
       else
            j = j + 1
    }
    
    // Test whether we've successfully found a common element    
    if (i < N && j < M && a(i) == b(j))
        Some(a(i))
    else
        None
}


(c)
def smallestInCommon(a: Array[Int], N: Int, b: Array[Int], M: Int,
                     c: Array[Int], L: Int): Int = {
    var i = 0; var j = 0; var k = 0
    // Invariant: 0 <= i <= N and
    //            0 <= j <= M and
    //            0 <= k <= L and
    //            a[0 .. i), b[0 .. j) and c[0 .. k) together are the smallest
    //                      i + j + k elements in a, b and c considered together and 
    //            there is no element common to all a[0 .. i), b[0 .. j) and c[0 .. k).
    while (i < N && j < M && k < L && !(a(i) == b(j) && a(i) == c(k))) {
    	if (a(i) <= b(j) && a(i) <= c(k))
    	    i = i + 1
    	else if (b(j) <= a(i) && b(j) <= c(k))
    	    j = j + 1
    	else
            k = k + 1
    }
    a(i) // We know that an answer surely exists, so this is well behaved
}


(d)
def smallestInCommon(as: Array[Array[Int]], n: Array[Int]): Option[Int] = {
    val m = as.size
    val i = new Array[Int](m)
    while (true) {
        // Look for the smallest "head" of the arrays to increment
        var minimum = (as(0)(i(0)), 0)
        var allEqual = true
        for (j <- 0 until m) {
            if (i(j) >= n(j)) // If one of the arrays si finished
                return None
            if (as(j)(i(j)) != as(0)(i(0)))
                allEqual = false
            if (as(j)(i(j)) < minimum._1)
                minimum = (as(j)(i(j)), j)
        }
    
        if (allEqual)
            return Some(minimum._1)
        else
            i(minimum._2) = i(minimum._2) + 1
    }
    Some(-1) // Should never reach this case
}


..........................................................................................


Question 2

(a) 
def record(f: Int => Int, emit: Int => Unit): Unit = {
    var maximum = f(1)
    emit(1)
    var n = 2

    // Invariant: 1 < n and
    //            maximum = max(f[1 .. n)) and
    //            emit was called on all records in [1 .. n),
    //            in ascending order, as required
    while (true) {
        var aux = f(n)
        if (aux > maximum) {
            maximum = aux
            emit(n)
        }
        n = n + 1
    }
}


(b)
def divisors(n: Int): Int = {
    var divs = 0
    // Invariant: 1 <= i <= n + 1 and
    //            divs = the number of divisors
    //                   of n in range [1 .. i)
    for (i <- 1 to n)
        if (n % i == 0)
            divs = divs + 1
    divs
}


(c) Since divisors(n) runs in time O(n) and record will make one call to f = divisors
for all i in [1 .. n], the total time is 1 + 2 + 3 + ... + n = n * (n + 1) / 2 = O(n^2),
so we're dealing with a quadratic growth rate.


(d) Say x is a divisor of n. Then, the only prime factors x may have are p1, p2, ..., pk.
p1's exponent in x may be any integer in range [0 .. i1] - there are (i1 + 1) such choices
p2's exponent in x may be any integer in range [0 .. i2] - there are (i2 + 1) such choices
...
pk's exponent in x may be any integer in range [0 .. ik] - there are (ik + 1) such choices

Most importantly, any combination of these choices makes for a valid divisor of n.
Therefore, by the product rule, n has (i1 + 1)(i2 + 1)...(ik + 1) divisors, as expected.


(e)
def divisors2(n: Int): Int = {
    var divs = 1
    var cpN = n
    var p = 2
    // Invariant: 2 <= p and
    //            cpN = n without all of its
    //                  prime factors < p and
    //            divs = the number of divisors
    //                   of n / cpN
    while (p <= cpN) {
        if (cpN % p == 0) { // p is prime for sure in this case
            var cnt = 1
            cpN = cpN / p
            // Invariant: cnt = the number of p's in
            //                  n / cpN's prime factorization
            while (cpN % p == 0) {
                cpN = cpN / p
                cnt = cnt + 1
            }
            divs *= (cnt + 1)
        }
    }
    divs
}


(f) The second function, divisors2, is, on average, much faster because most numbers have
a few very small prime factors which will be removed from cpN on the first few iterations
of the main while loop, thus greatly reducing the range p has to walk through, as well
as the total number of division operations.


..........................................................................................


Question 3

No supposed to be attempted, as it's part of last year's IP2 paper (which is a course
we're still to study in the term to come).


..........................................................................................


Question 4

(a)
def swap(i: Int, j: Int): Unit = {
    val aux = m(i)
    m(i) = m(j)
    m(j) = aux
}

def backswap(i: Int, j: Int, n: Int): Unit = {
    if (n > 0) {
        swap(i, j)
        backswap(i + 1, j + 1, n - 1)
    }
}


(b)
def reverse(i: Int, n: Int): Unit = {
    if (n > 1) {
        swap(i, i + n - 1)
        reverse(i + 1, n - 2)
    }
}


(c) (i)  
def rotate(i: Int, n: Int, k: Int): Unit = {
    reverse(i, n - k)
    reverse(i + n - k, k)
    reverse(i, n)
}


(ii)
def rotate(i: Int, n: Int, k: Int): Unit = {
    if (0 < k && k < n) {
        if (k < n - k) {
            backswap(i, i + n - k, k)
            rotate(i + k, n - k, k)
        }
        else {
            backswap(i, i + k, n - k)
            rotate(i, k, 2 * k - n)
        }
    }
}


(iii) Since (ii) is tail recursive, we can directly translate it
into an iterative procedure:

def rotate(_i: Int, _n: Int, _k: Int): Unit = {
    var i = _i; var n = _n; var k = _k
    while (0 < k && k < n) {
        if (k < n - k) {
            backswap(i, i + n - k, k)
            i = i + k
            n = n - k
        }
        else {
            backswap(i, i + k, n - k)
            val aux = k
            k = 2 * k - n
            n = aux
        }
    }
}


(iv) 
def rotateBy1(i: Int, n: Int): Unit = {
    val x: T = m(i + n - 1)
    for (j <- i + n - 2 to i by -1)
        m(j + 1) = m(j)
    m(i) = x
}

def rotate(i: Int, n: Int, k: Int): Unit = {
    if (k > 0) {
        rotateBy1(i, n)
        rotate(i, n, k - 1)
    }
}


(d) For simplicity, I will count reads and writes together, naming both of them
"accesses". Note that a swap operation takes 3 accesses.

     (i)   In this case each element takes part in at most 2 swap operations. Thus the
           total cost is 2 * 3 * n  = 6 * n accesses.
(ii / iii) In this case one can note that with every swap operation executed by backswap
           at least one of the two swapped elements ends up in its final position,
           meaning there can be at most n backswap swap operations overall. In turn,
           this means that the rotate procedure will use at most 3 * n access operations
           overall.
    (iv)   This is certainly the worst way to implement rotate. One rotateByOne call
           uses up exactly n + 1 access operations. This means that rotate will make
           exactly k * (n + 1) access operations, which is O(n^2) if k = O(n).


(f) This has been misplaced, it actually belongs to Question 3 above.


..........................................................................................  
-- Sheet 2 --


Question 1

class Tree(val datum: Int, val left: Tree, val right: Tree);


(a)
def preorder(t: Tree): Unit = {
    println(t.datum)
    if (t.left != null)
        preorder(t.left)
    if (t.right != null)
        preorder(t.right)
}


(b)



..........................................................................................


Question 2

(a) heapAt(i) = lchild(i) < N => a(i) >= a(lchild(i)) and
                rchild(i) < N => a(i) >= a(rchild(i))

By definition, this is equivalent to:

    heapAt(i) = 2 * i + 1 < N => a(i) >= a(2 * i + 1) and
                2 * i + 2 < N => a(i) >= a(2 * i + 2)

Now, because i >= N / 2, we deduce that 2 * i + 1 >= N and 2 * i + 2 >= N, so:

    heapAt(i) = True => a(i) >= a(2 * i + 1) and
                True => a(i) >= a(2 * i + 2)

Which is equivalent to:

    heapAt(i) = True and
                True

Or,

    heapAt(i) = True

As expected.


(b) 
// Auxiliary function, swaps the values of nodes i and j
def swap(i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

// The required function
def siftDown(_n: Int, end: Int) = {
    var n = _n
    // Invariant: 0 <= n <= end <= N   and
    //            heapAt[n0 .. n)      and
    //            heapAt[n + 1 .. end) and
    //            a is a rearrangement of a0
    while (n < end) {
        val l = lchild(n); val r = rchild(n)
        if (l >= end) // If n has no valid children, then stop
            n = end
        else if (r >= end) { // If n only got a left child
            if (a(l) > a(n)) { // See if swapping n with it is necessary
                swap(n, l) // And either do the swap and continue
                n = l
            }
            else
                n = end   // Or stop, as the heap property is satisfied
        }
        else {
            if (a(l) > a(r)) { // See which of the two children has the larger value
                               // and do swaps accordingly, similar to the former case
                if (a(l) > a(n)) {
                    swap(n, l)
                    n = l
                }
                else
                    n = end
            }
            else {
                if (a(r) > a(n)) {
                    swap(n, r)
                    n = r
                }
                else
                    n = end
            }
        }
    }
}


The idea is to swap n with its son of larger value whenever !heapAt(n), stopping as soon
as heapAt(n) evaluates to true.


(c)
def heapify = {
    // Invariant: -1 <= n < N and
    //            heapAt[(n + 1) .. N) and
    //            a is a rearrangement of a0
    for (n <- (N - 1) to 0 by -1)
        siftDown(n, N)
}


(d) Consider the function parent(n) = (n + 1) / 2 - 1 such that for all 0 < n < N we have
lchild(parent(n)) = n or rchild(parent(n)) = n.
Then, because heapAt holds for all 0 < n < N, we have that a(n) <= a(parent(n)) <=
a(parent(parent(n))) <= ... <= a(0) and so a(0) is the largest element in a[0 .. end).


(e)
def heapsort = {
    heapify
    // Invariant: -1 <= n < N
    //            a is a rearrangement of a0 and
    //            a(n .. N) consists of the largest N - n - 1 elements of a0 and 
    //           heapAt[0 .. n]
    for (n <- (N - 1) to 0 by -1) {
        swap(0, n)
        siftDown(0, n)
    }
}


..........................................................................................


Question 3

(a)
class Node(val datum: Int, val next: ListNode)

class IntList(headNode: Node) {
    def this() = this(null) // The list is initially empty
    ...   
}

I've chosen not to use a dummy header node, as it mostly complicates things in this case,
so headNode will be null for an empty list and its datum will correspond to the first
element of the represented list otherwise.
I've made the default constructor take the header node as a parameter to help in writing
other methods later (e.g. tail and cons).

Now, for a suitable abstraction function, define the metafunction L(node: Node) s.t.:
    L(null) = []
    L(node) = node.datum : L(node.next)

Then,
    Abs: list = L(headNode)

(b)
// Is the list empty?
def isEmpty = headNode == null

// Return the first element of the list
def head = headNode.datum

// Returns a list containing all except the first element of the current list
def tail = new IntList(headNode.next)

// Return a new list containing x followed by the elements of the current list
def cons(x: Int) = new IntList(new Node(x, headNode))


(c)

First, define a helper function (which will also come in handy to solve (d)):


def reverse = {
    // Invariant: ans contains all elements of the list
    //            between headNode and node, exclusive, in reverse order and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList
    while (node != null) {
        ans = ans.cons(node.datum)  
        node = node.next
    }
    ans
}

def map(f: Int => Int): IntList = {
    // Invariant: ans contains all elements of the list
    //            between headNode and node, exclusive, in reverse order, with f
    //            applied to their datum before being inserted to ans and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList

    while (node != null) {
        ans = ans.cons(f(node.datum))
        node = node.next
    }

    ans.reverse // The list has been built in reverse order, so reverse it
}


(d)
def filter(p: Int => Boolean): IntList = {
    // Invariant: ans contains all elements of the list whose datum satisfies p
    //            between headNode and node, exclusive, in reverse order and
    //            node is reachable from headNode by following "next" links
    var node = headNode
    var ans = new IntList

    while (node != null) {
        if (p(node.datum))
            ans = ans.cons(node.datum)
        node = node.next
    }

    ans.reverse // The list has been built in reverse order, so reverse it 
}


..........................................................................................


Question 4

(a)
def longestFrom(i: Int, j: Int): Int = {
    if (i < N && j < N && a(i) == a(j))
        1 + longestFrom(i + 1, j + 1)
    else
        0
}


(b)
def longestRepeated = {
    var ans(-1, -1, -1)
    for (i <- 0 until N)
        for (j <- i + 1 until N) {
            val longestFr = longestFrom(i, j)
            if (longestFr > ans._3)
                ans = (i, j, longestFr)   
        }
    ans
}

Simply iterate all (i, j) pairs with i != j (WLOG i < j) and compute the largest k such
that a[i .. (i + k)) = b[j .. (j + k)), by calling longestFrom(i, j). Record the pair
(i, j) with the largest k and return the triplet (i, j, k).

Time complexity: O(N^2 * bestk), because O(N^2) (i, j) pairs are being considered and the
                 maximum time longestFrom takes to complete is bestk + O(1).


(c) I will use standard terminology such as the suffix array and the LCP (longest common
prefix).
Consider the following (stronger) result:

If str[0 .. M) are M words, then LCP(str[i], str[j]) with 0 <= i < j < M is maximized
for an (i, j) pair such that i and j are consecutive when str is sorted in lexicographical
order.

To show this, assume WLOG that str is already sorted, then we need to show that
LCP(i, j) can only be maximum when j = i + 1. This is immediate from the observation that
LCP(i, i + 1) <= LCP(i, i + 2) <= ... <= LCP(i, M - 1), which is not hard to prove
formally. But, for an informal argument, consider how words with a common prefix form
a continuous subsequence in str and realize that, for this reason, the two words with the
largest LCP have to be consecutive in the sorted order, as expected.


(d)
def before(i: Int, j: Int) = {
    if (j >= N)
        false
    else if (i >= N)
        true
    else if (a(i) == a(j))
        before(i + 1, j + 1)
    else
        a(i) < a(j)
}

This runs in time O(bestk) worst case.

(e)
def getSuffixArray = {
    val suff = new Array[Int](Int)
    for (i <- 0 until N)
        suff(i) = i
    val orderedSuffixes = suff.sortWith(before)
    orderedSuffixes
}


(f)
def longestRepeated = {
    val suffixArray = getSuffixArray
    ans = (-1, -1, -1)
    for (i <- 0 until N - 1) {
        val longestFr = longestFrom(suffixArray(i), suffixArray(i + 1))
        if (longestFr > ans._3)
            ans = (suffixArray(i), suffixArray(i + 1), longestFr)   
    }
    ans 
}

As guided by the previous parts, we compute the suffix array of a by calling the
appropriate part (e) function and then only consider (i, i + 1) pairs, as showed to be
enough in part (c). The total complexity is O(N * bestk * log N) for the suffix array and
O(N * bestk) for the remaining checks, totalling to O(N * bestk * log N).

Note: 
There are numerous linear time algorithms for computing the suffix array, such as the
classical "mod 3" divide-and-conquer algorithm. Afterwards, the LCP's of the consecutive
entries in the suffix array are known as the "LCP array". Kasai's algorithm is an
ingenious 5 lines long algorithm for computing the LCP array in linear time with constant
additional memory.


..........................................................................................
-- Sheet 3 --


Question 1

(a)
Define Sum [j = a, j = b, expr(j)] = expr(a) + expr(a + 1) + ... + expr(b) and
       Prod[j = a, j = b, expr(j)] = expr(a) * expr(a + 1) * ... * expr(b).


def digsToInt(xs: Array[Int], bs: Array[Int]): Int = {
    // Invariant: -1 <= i < N and
    //            ans = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i+1, k = j-1, bs(k)]]
    var ans = 0
    for (i <- N - 1 to 0 by -1)
        ans = ans * bs(i) + xs(i)
    ans
}

Initialization:
i = N - 1, ans = 0, so the invariant holds true initially.

Invariant maintenance:
ans                 = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i+1, k = j-1, bs(k)]]
ans * bs(i)         = Sum[j = i+1, j = N-1, xs(j) * Prod[k = i,   k = j-1, bs(k)]]
ans * bs(i) + xs(i) = Sum[j = i  , j = N-1, xs(j) * Prod[k = i,   k = j-1, bs(k)]]

So, by executing ans = ans * bs(i) + xs(i), i = i - 1, the invariant is maintained.

(b) 
Pre: 0 <= n < Prod[j = 0, j = N - 1, bs(j)] 
def IntToDigs(n: Int, bs: Array[Int]): Array[Int] = {
    val xs = new Array[Int](N)
    xs(0) = n
    // Invariant 1 <= i <= N + 1 and
    //           for all 0 <= j < i - 1 we have that 0 <= xs(j) < bs(j) and
    //           digsToInt(xs, bs) = n
    for (i <- 1 until N) {
        xs(i)     = xs(i - 1) / bs(i - 1)
        xs(i - 1) = xs(i - 1) % bs(i - 1)
    }
    xs
}

Initialization:
i = 1, xs(0) = n, so the invariant holds true initially.

Invariant maintenance:
Note that performing xs(i) = xs(i - 1) / bs(i - 1), xs(i - 1) = xs(i - 1) % bs(i - 1)
leaves digsToInt(xs, bs) unchanged, as it's simply turning any excess xs(i - 1) into
a smaller amount in xs(i) (e.g. informally, it's exchanging many (>= 60) seconds for fewer
(>= 1) minutes).
With this in mind, coupled with the fact that xs(i - 1) < bs(i - 1) once
xs(i - 1) %= bs(i - 1) has been executed, one can see how the invariant is being
maintained.

Now, overall correctness follows from the fact that n is bounded above (see precondition)
such that the excess left at the end in xs(N - 1) is smaller than bs(N - 1).


..........................................................................................


Question 2

(a) 
/* State: lst: [Int]
 * Init:  lst = []  */
trait ReversableBuffer {
    // Add x to the end of the buffer
    // Post: lst = lst0 ++ [x]
    def append(x: Int)
    
    // Add x to the start of the buffer
    // Post: lst = x : lst0
    def prepend(x: Int)
    
    // Remove and return the i-th element, counting from zero
    // Post: lst = take i lst0 ++ drop (i + 1) lst0 and return lst0 !! i
    def get(i: Int): Int
    
    // Reverse the contents of the buffer
    // Post: lst = reverse lst
    def rev
}


(b)


..........................................................................................


Question 3

(a)
// Pre:  a is an array of integers and
//	 n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int)


(b) Helper function that swaps a(i) and a(j):
// Pre: 0 <= i, j < a.size
// Post: a(i) = a0(j) and
//       a(j) = a0(i) and
//       a(k) = a0(k) for all 0 <= k < a.size, k != i, j 
def swap(a: Array[Int], i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

Classical ternary partition subroutine:
// Pre: 0 <= l < r < a.size and
//      a(l) = value
// Post: Returns (x, y) and permutes array a[l .. r) such that:
//       All elements 0 <= k < a.size with a0(k) = value are now in [x .. y) and
//       All elements 0 <= k < a.size with a0(k) < value are now in [0 .. x) and
//       All elements 0 <= k < a.size with a0(k) > value are now in [y .. a.size)
def ternaryPartition(a: Array[Int], l: Int, r: Int, value: Int): (Int, Int) = {
    var firstEqual = l
    var lastUnexplored = r - 1 
    var i = l + 1
    // Invariant: a[l .. r) is a permutation of a0[l .. r) and
	//			  a(k) = a0(k) for all k not in [l .. r)
    //            1 <= l + 1 <= i <= lastUnExplored + 1 <= r <= a.size and
    //            a[l .. firstEqual) < value and
    //            a[firstEqual .. i) = value and
    //            a(lastUnexplored .. r) > value
    while (i <= lastUnexplored) {
        if (a(i) < value) {
            swap(a, firstEqual, i)
            firstEqual = firstEqual + 1
            i = i + 1
        }
        else if (a(i) > value) {
            swap(a, i, lastUnexplored)
            lastUnexplored = lastUnexplored - 1
        }
        else
            i = i + 1
    }
    (firstEqual, lastUnexplored + 1)
}

Ternary Quicksort:
// Pre: 0 <= l < r <= a.size
// Post: Permutes a[l .. r) into non-decreasing order.
def quickSort(a: Array[Int], l: Int, r: Int): Unit = {
    if (r - l > 1) {
        val pivot = a(l) // Take a(l) to be the pivot
        val split = ternaryPartition(a, l, r, pivot) // Partition around it
        quickSort(a, l, split._1) // Sort all values < pivot
        quickSort(a, split._2, r) // Sort all values > pivot
    }
}

Interface function:
// Pre:  a is an array of integers, n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int) = {
    quickSort(a, 0, n)
}

Now, for a very formal proof of correctness one would also need to carefully show how the
invariant is being maintained inside the ternaryPartition function and apply strong
induction on r - l to show that the quickSort function always correctly sorts a[l .. r).


(c) Iterative Ternary Quicksort:
// Pre: 0 <= l < r <= a.size
// Post: Permutes a[l .. r) into non-decreasing order.
def quickSort(a: Array[Int]): Unit = {
    val q = scala.collection.mutable.Queue[(Int, Int)]()
    q.enqueue((0, a.size))
    
    // Invariant: a is a permutation of a0 and
    //            sorting each range a[l .. r) with (l, r) in q would render a sorted and
    //            any two distinct ranges corresponding to elements in q are disjoint
    // Variant:   The sum of r - l over (l, r) in q
    while (!q.isEmpty) {
        // (l, r) = q.dequeue
        val aux = q.dequeue
        val l = aux._1
        val r = aux._2
        
        // If not in base case
        if (r - l > 1) {
            val pivot = a(l) // Take a(l) to be the pivot
            val split = ternaryPartition(a, l, r, pivot) // Partition around it
            q.enqueue((l, split._1)) // Sort all values < pivot, later
            q.enqueue((split._2, r)) // Sort all values > pivot, later
        }
    }
}

Also, change the calling function appropriately:
// Pre:  a is an array of integers, n = a.length
// Post: a is a rearrangement of a0 and
//       a(i) < a(i + 1) for all 0 <= i < n - 1
def sort(a: Array[Int], n: Int) = {
    quickSort(a)
}

Note: This is like doing BFS on the recursion tree.


..........................................................................................


Question 4

(a)
def contain(w: String): Boolean = {
    var node = this
    for (c <- w) {
        if (node == null)
            return false
        node = node.children(toIndex(c))
    }
    return node != null && node.complete
}


(b)
def add(w: String): Unit = {
    var node = this
    for (c <- w) {
        if (node.children(toIndex(c)) == null)
            node.children(toIndex(c)) = new Trie;
        node = node.children(toIndex(c))
    }
    node.complete = true
}


(c)
def allWords(ls: String): List[String] = {
    if (ls.length == 0) {
        if (complete)
            return List[String]("")
        else
            return List[String]()
    }
    
    var ans = List[String]()
    for (i <- 0 until ls.length) {
        val c = ls.charAt(i)
        if (children(toIndex(c)) != null) {
            val subans = children(toIndex(c)).allWords(ls.substring(0, i).concat(ls.substring(i + 1))).map(x => c.toString.concat(x))
            ans = ans ++ subans
        }
    }
    ans
}


..........................................................................................
-- Sheet 4 --


Question 1

(a)
// Helper function, swaps the values of a(i) and a(j)
def swap(i: Int, j: Int) {
    val aux = a(i)
    a(i) = a(j)
    a(j) = aux
}

def partition(l: Int, r: Int, p: Int): Int = {
	// Invariant: a[l .. r) is a permutation of a0[l .. r) and
	//			  a(k) = a0(k) for all k not in [l .. r) and
	//            l <= j <= i <= r and
	//            a[l .. j) < p <= a[j .. i)
	var j = l
	for (i <- l until r)
		if (a(i) < p) {
			swap(i, j)
			j = j + 1
		}
	j
}


(b) val k = partition(0, N, p)

    (i) If k < p, we know that a[0 .. k) < p, so a contains k < p values in range
		[0 .. p). Therefore, by the Pigeonhole Principle, there ought to be a missing
		value x in range [0 .. p), contained in a[0 .. k).
   (ii) If k >= p, we know that a[0 .. k) < p, so a contains k >= p values in range
		[0 .. p), meaning that a contains at most N - p values in range [p .. N], which
		is made up of N - p + 1 integers. Therefore, by the Pigeonhole Principle, there
		ought to be a missing value x in range [p .. N + 1).
   

(c)
def findMissing: Int = {
	var arrayL = 0; var arrayR = N
	var l = 0; var r = N + 1
	// Invariant: a is a permutation of a0 and
	//            one of the missing values x in a is in [l .. r) and
	//            l <= a[arrayL .. arrayR) <= r and
	//            for all 0 <= k < N not in [arrayL .. arrayR), a(k) not in [l .. r] and  
	// 			  arrayR - arrayL < r - l
	while (arrayL < arrayR) {
		val mid = (l + r) / 2
		val k = partition(arrayL, arrayR, mid)
		if (k - arrayL < mid - l) {
			arrayR = k
			r = mid
		}
		else {
			arrayL = k
			l = mid
		}
	}
	l
}


This simply generalizes the idea stated in part (b):
Maintain two ranges [arrayL .. arrayR) and [l .. r) such that all occurrences of
values [l .. r) in a are in a[arrayL .. arrayR). Given that arrayR - arrayL < r - l,
the Pigeonhole Principle tells that there must be an x in [l .. r) that does not occur
in a[arrayL .. arrayR). It holds true that whichever of [l .. mid) and [mid .. r) accounts
for less values in a[arrayL .. arrayR) than its length has to be the right subinterval to
continue our search into (again, by the Pigeonhole Principle).


The runtime is dominated by the partition function calls, which run in total time

   arrayR0 - arrayL0 +
   arrayR1 - arrayR1 +
   ...
 
Where (arrayLi, arrayRi) are the successive values (arrayL, arrayR) takes.
The invariant tells us that, at all times, arrayR - arrayL < r - l, so our sum is bounded
from above by

	r0 - l0 +
	r1 - l1 +
	...
	
Where, similarly, (li, ri) are the successive values (l, r) takes.
Now, knowing that r - l is about halved (to be rigorous, round N up to the nearest power
of 2 minus 1) with every iteration of the binary search loop, we may conclude that our
sum is bounded from above by:

	(r0 - l0) * (1 + 1 / 2 + 1 / 4 + ...) = (N + 1) * 2 = O(N), as expected.
	
	
Note: There is neat way to solve (c) in linear time, constant additional space and without
modifying array a at any point during runtime (a clever use of Floyd's Cycle Finding
Algorithm).


..........................................................................................


Question 2

(a)
// Invariant: 0 <= i <= N and
//            For all 0 <= k < i, rowCount(k)
//            has been correctly computed,
//            according to the definition of rowCount
for (i <- 0 until N) {
	// Invariant: 0 <= j <= N and
	//            For all 0 <= k < j, rowCount(i)(k)
	//            has been correctly computed,
	//            according to the definition of rowCount
	for (j <- 0 until N)
		if (a(i)(j)) {
			if (j > 0)
				rowCount(i)(j) = 1 + rowCount(i)(j - 1)
			else
				rowCount(i)(j) = 1
		}
}


(b) In order to see why the given formula may be used to calculate the maximum-area
all-true rectangle with the top-right corner in cell (i, j), one has to imagine iterating
over all possible down row bounds of the rectangle (i.e. k - 1 in this case). Now, with
(i, j, k) fixed, the only variable dimension of the rectangle is its left column bound, x.
x has to be picked such that a[i .. k)(x .. j] is all-true, implying, by definition, that
j - rowCount(p)(j) <= x < j, for all i <= p < k.
In other words:

(max of (j - rowCount(p)(j)) over i <= p < k) <= x < j

Or,

j - (min of rowCount(p)(j) over i <= p < k) <= x < j


Now, as we want the maximum area, set x = j - (min of rowCount(p)(j) over i <= p < k) to
get an area of (k - i) * (j - x) = (k - i) * (min of rowCount(p)(j) over i <= p < k), as
expected.

def maxRectangleAt(i: Int, j: Int): Int = {
	var minimum = N + 1 // = INF
	var ans = 0
	// Invariant: i + 1 <= k <= N + 1 and
	//            minimum = min(rowCount[i .. (k - 1))(j) and
	//            ans = max{(p - i) * min{rowCount(m)(j): i <= m < p}: i < p < k}
	for (k <- i + 1 to N) {
		if (rowCount(k - 1)(j) < minimum)
			minimum = rowCount(k - 1)(j)
		val aux = (k - i) * minimum
		if (aux > ans)
			ans = aux
	}
	ans
}


(c)
def maxRectangle = {
	var ans = 0
	for (i <- 0 until N)
		for (j <- 0 until N) {
			val ansHere = maxRectangleAt(i, j)
			if (ansHere > ans)
				ans = ansHere
		}
	ans
}

Note: There is a standard way to do this in O(N^2) time using the same rowCount array
together with a linear time algorithm for solving the maximum-area rectangle in a
histogram (the standard one consists of two stack-based computations).


.........................................................................................


Question 3

(a)
val head = new Node(Int.MinValue)
val tail = new Node(Int.MaxValue)
for (i <- 0 until NumLevels) {
	head.nexts(i) = tail
	tail.nexts(i) = null // Although hopefully this
						 // should never get used
}


(b)
def getList(node: Node, level: Int): List[Node] = {
	if (node == tail)
		List(node)
	else
		List(node) ++ getList(node.nexts(level), level)
}

// Abs: lst = getList(head, 0).map(n => n.datum)
//      (I considered the state to be a Scala List instead of a Haskell List)
// DTI: For all 0 <= i < NumLevels
//          getList(head, i).map(n => n.datum) is sorted is non-decreasing order and
//          getList(head, i) is finite and it ends with tail
//          tail.nexts(i) = null
//      For all 0 <= i < NumLevels - 1
//          if n in getList(head, i), n.nexts(i) = null => n.nexts(i + 1) = null and
//          getList(head, i + 1) is a subsequence of getList(head, i)
//      head.datum = Int.MinValue
//      tail.datum = Int.MaxValue
//      No nodes other than head and tail have their datum field set to
//          Int.MinValue or Int.MaxValue
//      For all nodes other than tail, nexts(0) != null


(c)
def findPreds(x: Int): Array[Node] = {
	var currentLevel = NumLevels - 1
	var node = head
	val ans = new Array[Node](NumLevels)
	while (currentLevel >= 0) {
		if (node.nexts(currentLevel).datum < x)
			node = node.nexts(currentLevel)
		else {
			ans(currentLevel) = node
			currentLevel = currentLevel - 1
		}
	}
	ans
}

(d)
def contains(x: Int): Boolean = {
	val aux = findPreds(x)
	val nd = aux(0).nexts(0)
	nd.datum == x
}


(e)
def add(x: Int) = {
	val aux = findPreds(x)
	val cnt = pickLevel
	val node = new Node(x)
	for (i <- 0 to cnt) {
		node.nexts(i) = aux(i).nexts(i)
		aux(i).nexts(i) = node
	}
}


(f)
def delete(x: Int) = {
	if (contains(x)) {
		val aux = findPreds(x)
		val node = aux(0).nexts(0)
		for (i <- 0 until NumLevels)
			if (node.nexts(i) != null)
				aux(i).nexts(i) = node.nexts(i)
	}   
}


.........................................................................................


Question 4

(a)
for (i <- 0 until N)
    rows(i) = List()

    
(b)
// DTI: rows.size = N and
//      for all 0 <= i < N:
//          rows(i).filter(p => p._1) is ordered in strictly
//              increasing order, with all elements in [0 .. N)
//          rows(i).filter(p => p._2) has no zero entries


(c)
def get(i: Int, j: Int): Double = {
    val aux = rows(i).filter(p => p._1 == j)
    if (aux == List())
        0.0
    else
        aux.head._2
}


(d)
def set(i: Int, j: Int, x: Double): Unit = {
    if (x != 0)
        rows(i) = rows(i).takeWhile(p => p._1 < j) ++ List((j, x)) ++ rows(i).dropWhile(p => p._1 <= j)
    else // Edge case
        rows(i) = rows(i).takeWhile(p => p._1 < j) ++ rows(i).dropWhile(p => p._1 <= j)
}


(e)
def scale(s: Double): SparseMatrix = {
    val ans = new SparseMatrix(N)
    if (s == 0) // Edge case, if we are nullifying the matrix
        return ans
    for (i <- 0 until N)
        for (p <- rows(i))
            ans.set(i, p._1, p._2 * s)
    ans
}


(e)
def transpose: SparseMatrix = {
    val ans = new SparseMatrix(N)
    for (i <- 0 until N)
        for (p <- rows(i))
            ans.set(p._1, i, p._2)
    ans
}


(f)
def mult(that: SparseMatrix): SparseMatrix = {
    require(N == that.N) // Check for compatibility
    val ans = new SparseMatrix(N)
    for (i <- 0 until N)
        for (j <- 0 until N) {
            // Dot product row i with column j
            var sum: Double = 0.0
            for (k <- 0 until N)
                sum = sum + get(i, k) * that.get(k, j)
            ans.set(i, j, sum)
        }
    ans
}